<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<!--
        	1-面向过程的选项卡例子

2-面向过程的选项卡例子

3-面向对象方式的选项卡

4-面向对象的概念
/*
			 * 面向对象
			 * 	它是一种编程思想
			 * 
			 * 对象
			 * 	可以添加属性（变量）与方法（函数）的
			 * 
			 * 
			 * 面向对象的写法特点
			 * 	1、把功能写成一个函数
			 * 	2、函数必需在对象身上，调用的时候拿对象.方法名()
			 * 	3、对象身上的功能可以继承
			 */

5-创建对象


			/*
			 * 创建对象的方法
			 * 	1、{}			字面量创建对象
			 * 	2、new Object()	
			 * 
			 * 创建完的对象有两个特点
			 * 	1、添加属性
			 * 		描述对象的特征
			 * 		属性的值为非函数的任意数据类型
			 * 	2、添加方法
			 * 		实现对象的一些功能
			 * 		方法的值为函数
			 */
			
			//第一种创建对象的方法
			var person={
				name:'老王',
				age:30,
				sing:function(){
					console.log('五环之歌');
				}
			};
			
			//console.log(person);
			person.height='180CM';
			person.play=function(){
				console.log('打飞机');
			};
			
			//console.log(person);
			
			
			//第二种创建对象的方法
			var person2=new Object();
			person2.name='小王';
			person2.age=18;
			person2.play=function(){
				console.log('打小飞机');
			};
			
			//console.log(person2)

6-封装函数创建对象


			//工厂方式
			function createPerson(name,age){
				var obj=new Object;
				
				obj.name=name;
				obj.age=age;
				
				obj.say=function(){
					console.log('我叫'+obj.name);
				}
				
				return obj;
			}
			
			var p1=createPerson('老王',30);
			var p2=createPerson('小王',18);
			
			//console.log(p2);
			
			p1.say();
			p2.say();
		

7-new
 * new
			 * 	一元运算符，后面只能跟函数，用来调用函数
			 * 
			 * 调用函数的方式
			 * 	1、new 函数名
			 * 		没有参数的情况下用这种方式
			 * 	2、new 函数名()
			 * 
			 * 用new调用函数的执行过程
			 * 	1、自动创建一个空对象
			 * 	2、把函数内部的this指向创建的这个对象
			 * 	3、在函数执行完成以后自动返回创建的那个对象，即使函数里面没有return
			 * 		函数里有return
			 * 			1、return的是对象
			 * 				返回这个对象
			 * 			2、return的是非对象
			 * 				返回自动创建的那个对象
			 * 
			 * 注意：
			 * 		1、用new调用的函数，得到的永远是一个对象，不管函数有没有返回值
			 * 		2、使用new调用函数，这个函数就是一个用来创建对象的函数（构造函数)

8-构造函数


			/*
			 * 构造函数
			 * 	创建并初始化对象的函数，并且需要用new来调用函数，不用new调用的话与普通的函数就没有区别
			 * 
			 * Date()		new Date()
			 * Array()		new Array()
			 * 
			 * 通过构造函数new出来的对象叫实例，创造对象的过程叫实例化
			 * 
			 */
			
			function Person(name,age){
				/*
				 * 1、创建一个空对象
				 * 		var obj=new Object;
				 * 2、把this指向创建的对象
				 * 		this=obj
				 */
				
				
				this.name=name;
				this.age=age;
				
				this.say=function(){
					console.log('我叫'+this.name);
				};
				
				/*
				 * 3、函数执行完毕后，返回创建的对象
				 * 		return obj;
				 */
			}
			
			var p1=new Person('老王',30);		//一个实例
			p1.say();
			
			var p2=new Person('小王',18);		//一个实例
			p2.say();
		
09-构造函数的问题

	/*
			 * 构造函数
			 * 	创建并初始化对象的函数，并且需要用new来调用函数，不用new调用的话与普通的函数就没有区别
			 * 
			 * Date()		new Date()
			 * Array()		new Array()
			 * 
			 * 通过构造函数new出来的对象叫实例，创造对象的过程叫实例化
			 * 
			 * 
			 * 构造函数的问题
			 * 	性能问题会造成资源浪费
			 * 	
			 *

10-原型
/*
			 * 原型	prototype
			 * 	概念
			 * 		函数身上的属性，每一个函数身上都有这个属性，它的值是一个对象
			 * 	用途
			 * 		它身上可以放属性与方法，如果与构造函数相结合的话，通过构造函数创建的对象就会具有它身上的属性与方法
			 * 		对象是通过构造函数创建的，那prototype就是这个对象的原型对象
			 * 		建议把一些公用的属性或者方法都放到构造函数的原型身上
			 * 

11-__proto__
			/*
			 * __proto__
			 * 	对象身上的属性，每一个对象身上都会有这个属性。它的值也是一个对象，它的值就是它对应的构造函数的prototype的值
			 * 	对象.__proto__===构造函数.prototype
			 * 
			 * 	对象之所以能够继承原型身上的属性与方法，是因为每个对象身上都有一个__proto__，那__proto__的值指向了构造函数的prototype
			 * 	
			 */
			
			var arr=[1,2,3];
			console.log(arr);
			
			//arr是一个数组的实例 -> 数组对象原型(Array) -> 对象(Object)

			
12-原型链
/*
			 * 原型链
			 * 	对象与原型之间的关系（链接）
			 * 
			 * 原型链查找规则
			 * 	当我们调用一个对象身上的属性或者方法的时候，它就会有一个查找规则
			 * 		1、首先会在自己身上去找，如果有的话就用自己的
			 * 		2、如果没有的话，它就在该对象的__proto__下查找，因为__proto__这个属性是指向对应的构造函数身上的protytpe，把它查找的时候找的就是构造函数的原型
			 * 		3、如果原型身上也没有的话，那它会继续往外面找，直到找到最顶层的Object身上的prototype
			 */
13-面向对象的写法

			/*function 构造函数(){
				this.属性＝??;
			}
			构造函数.prototype.方法=function(){}
			
			var 实例对象=new 构造函数();
			实例对象.方法();*/
		
14-包装对象
/*
			 * 包装对象
			 * 	在js内部，当我们去调用字符串、数字、布尔值这些基本数据类型的属性或者方法的时候，js会在内部先把这些基本数据类型转成一个对应的对象类型（包装对象），然后再去调用包装对象身上的这些属性或者方法
			 * 
			 * 包装对象有
			 * 	String
			 * 	Number
			 * 	Boolear
			 * 
			 * 注意：
			 * 		1、null与undefined没有对应的包装对象
			 * 		2、基本数据类型只能使用对应的包装对象身上的属性或者方法，不能添加
			 * 			因为使用后，包装对象就消失了，所以只能用，不能添加
			 */

14-面向对象录播图/原则
/*
			 * 写面向对象的原则
			 * 	1、所有的变量都做属性
			 * 		属性需要写在构造函数里
			 * 	2、所有的函数都要做为方法
			 * 		方法添加到构造函数的原型
			 * 	3、this指向，在事件或者定时器里是访问不到真正的this，需要在外面存一下this
			 */

15-hasOwnProperty
/*
			 * hasOwnProperty
			 * 	作用
			 * 		判断一个属性是不是自己对象身上的
			 * 	语法
			 * 		对象.hasOwnProperty(属性)
			 * 	参数
			 * 		要检测的属性
			 * 	返回值
			 * 		true			自身属性
			 * 		false		非自身属性
			 * 	注意
			 * 		1、这个方法是Object身上的方法
			 * 		2、不会顺着原型链往外面去查找属性，只查找自身
			 */

16-constructor
*
			 * constructor
			 * 	概念
			 * 		每个对象身上都会有这个属性，默认指向该对象对应的构造函数
			 * 		这个属性不是放在对象身上，放在对应的原型对象身上
			 * 	作用
			 * 		查看对象的构造函数
			 * 	语法
			 * 		对象.constructor
			 * 	返回值
			 * 		对象的构造函数
			 * 
			 * 	他可以用来做数据类型的判断
			 */

17-constructor问题
* constructor
			 * 	概念
			 * 		每个对象身上都会有这个属性，默认指向该对象对应的构造函数
			 * 		这个属性不是放在对象身上，放在对应的原型对象身上
			 * 	作用
			 * 		查看对象的构造函数
			 * 	语法
			 * 		对象.constructor
			 * 	返回值
			 * 		对象的构造函数
			 * 	注意：
			 * 		这个属性是可以被修改的
			 */

18- for in




19-instanceof
*
			 * instanceof
			 * 	作用
			 * 		二元运算符，用来查找对象与构造函数在原型链上有没有关系
			 * 	语法
			 * 		对象 instanceof 构造函数
			 * 	返回值
			 * 		true			有关系
			 * 		false		没关系
			 * 
			 * 	可以用来做类型判断

20-toString
/*
			 * toString
			 * 	作用
			 * 		把对象类型转成字符串
			 * 	注意
			 * 		系统对象下的这个方法都是它对应原型对象身上的方法，自己写的对象下的这个方法是属于Object原型身上的方法
			 */

21 call
/*
			 * call
			 * 	作用
			 * 		调用函数并且改变this的指向
			 * 	语法
			 * 		函数名.call(thisArg,arg1,arg2...)
			 * 	参数
			 * 		thisArg			函数中this指向的值
			 * 		arg1,arg2...		从call里的第二个参数开始，都是真正函数里的参数
			 * 	返回值
			 * 		undefined
			 * 
			 * 	注意：thisArg的值为null或者undefined的时候，this是指向window
			 */

22 apply
/*
			 * apply
			 * 	作用
			 * 		调用函数并且改变this的指向
			 * 	语法
			 * 		函数名.call(thisArg,[arg1,arg2...])
			 * 	参数
			 * 		thisArg				函数中this指向的值
			 * 		[arg1,arg2...]		从call里的第二个参数开始，都是真正函数里的参数，但是它的参数需要放在数组里
			 * 	返回值
			 * 		undefined
			 * 
			 * 	注意：thisArg的值为null或者undefined的时候，this是指向window
			 */

23-赋值和引用

			var str1='kaivon';
			var str2='kaivon';
			console.log(str1==str2);			//true
			
			
			var obj1={a:10,b:20};
			var obj2={a:10,b:20};
			console.log(obj1==obj2);			//false
			
			
			//基本数据类型的赋值，就是把值复制了一下
			var n1=2;
			var n2=n1+5;
			console.log(n1,n2);		//2 7
			
			
			//复杂数据类型的赋值，它不光把值复制了一下，并且还复制了一下在内存中的引用地址
			var arr1=[1,2,3];
			var arr2=arr1;
			arr2.push(4);			//arr2与arr1的引用地址是相同的，所以无论修改哪个，两个都会变
			console.log(arr2);		//[1, 2, 3, 4]
			console.log(arr1);		//[1, 2, 3, 4]
			
			
			var arr3=[4,5,6];
			var arr4=arr3;
			arr4=[7,8,9];			//arr4又赋值了，所以就又开了一块内存，引用地址就不一样了
			console.log(arr4);		//[7, 8, 9]
			console.log(arr3);		//[4, 5, 6]
			
			
			//基本数据类型的比较，比较的是值相等就相等
			var n3=10;
			var n4=10;
			console.log(n3==n4);		//true
			
			
			//基本数据类型的比较，比较的不光是值，并且还要比较引用地址，如果两个都相等，那他们就相等
			var obj3={a:10,b:20};
			var obj4=obj3;
			console.log(obj3==obj4);		//true
		
24-浅拷贝与深拷贝

			var obj={a:10,b:20};
			//var obj2=obj;		//这样复制是复制了引用地址，不可以
			var obj={
				a:10,
				b:{
					c:22
				},
				d:[1,2,3],
				e:function(){
					console.log(1);
				}
			};
			
			//浅拷贝(如果对象数据里某个数据的类型也为对象的话，这种方法就不适用了)
			function copy(obj){
				var newObj={};
				
				for(var attr in obj){
					newObj[attr]=obj[attr];
				}
				
				return newObj;
			}
			
			var obj3=copy(obj);
			obj3.a=15;
			console.log(obj3);			//{a: 15, b: 20}
			console.log(obj);			//{a: 10, b: 20}
			
			
			/*var obj4=copy(obj);
			obj4.b.c=30;
			console.log(obj4);
			console.log(obj);*/
			
			
			//深拷贝
			function deepCopy(obj){
				//给一个跳出去的条件，这个条件表示当传进来的参数不是对象的时候，就不需要递归了
				if(typeof obj!='object'){
					return obj;
				}
				
				//如果要复制的对象里有个属性的值是数组，那复制的结果就必需还是数组
				if(obj instanceof Array){
					var newObj=[];
				}else{
					var newObj={};
				}
				
				for(var attr in obj){
					newObj[attr]=deepCopy(obj[attr])
				}
				
				return newObj;
			}
			var obj5=deepCopy(obj);
			obj5.b.c=30;
			obj5.d.push(4);
			obj5.e=function(){
				console.log(2);
			}
			console.log(obj5);
			console.log(obj);
			
			obj5.e();		//2
			obj.e();			//1	它身上的函数没有被改
		
25-继承


26-继承

/*
			 * 继承
			 * 		让一个对象拥有另一个对象的属性或者方法，并且自己添加的属性或者方法都不会影响到原来的对象
			 * 
			 * 属性继承
			 * 		通过call的方法调用构造函数继承属性
			 * 方法继承
			 * 		通过for in的方法继承原型身上的方法
			 * 
			 * 注意：
			 * 		1、继承其它对象的属性的时候，一定要用call去修正一下this的指向
			 * 		2、继承其它对象的方法的时候，不能直接赋值，要用for in的方法去赋值，不然会出现对象引用的关系
			 * 		
			 */

27拖拽继承例子



28-组件
/*
			 * js组件
			 * 	把一个效果或者功能用面向对象的方法封装起来，只提供给用户一些相关的方法或者数据接口
			 * 
			 * 特点
			 * 	易扩展，易维护。相互之间不会有影响
			 * 
			 * 组件的组成
			 * 	1、配置参数
			 * 		放在初始化函数里
			 * 	2、方法
			 * 		放在原型里的函数
			 * 	3、自定义事件
			 * 		除了系统以外的事件
			 * 		
			 */

29-初始化函数

/*
			 * 1、在哪里改颜色
			 * 		在初始化函数里修改
			 * 2、怎么改颜色
			 * 		把颜色放在一个函数里，通过传参的形式传到初始化的函数里，在用到的地方去调用一下这个函数就可以了
			 * 
			 */

30-初始化函数改进

31-配置参数与默认值

32-自定义事件
/*
			 * 自定义事件
			 * 	自己定义的事件，除了系统提供以外的事件。有利于多人协作开发，可扩展js原有事件
			 * 	需要用到事件绑定器、事件触发器
			 * 
			 * 	自定义事件其实就是调用函数，在指定的环境下让这个函数触发，就相当于事件了
			 */
			

33-自定义事件要素

/*
			 * 自定义事件三要素
			 * 	对象、事件名、事件处理函数
			 * 		1、可以利用对象数据结构里的key:value的形式把事件名字与事件处理函数对应起来
			 * 		2、把多个函数放到一个数组里，循环去执行数组里每个函数，就可以做到让所有函数都执行
			 * 
			 * 定义事件
			 * 	obj.events={
			 * 		'事件名1':[fn1,fn2],
			 * 		'事件名2':[fn3,fn4,fn5],
			 * 	}
			 * 
			 * 调用事件（循环去调）
			 * 	obj.events['事件名1'].fn1();
			 * 	obj.events['事件名1'].fn2();
			 * 		
			 */
			
34-自定义事件拖拽

35-滑块组件例子

			
        -->
	</body>
</html>
